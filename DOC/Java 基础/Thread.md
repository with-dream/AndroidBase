# Thread
一、开启线程的三种方式？
  分别是继承Thread类重写run方法、实现Runable接口和使用线程池
  【扩展】run()和start()方法区别
      start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。
      当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

二、线程同步的方法
  ①synchronized  即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态；
  ②同步代码块  即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步；
  ③使用特殊变量Volatile
  （1）volatile关键字为域变量的访问提供了一种免锁机制；
  （2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；
  （3）因此每次使用该域就要重新计算，而不是使用寄存器中的值；
  （4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。
  ④使用重入锁
  在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，
  它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力；
  ⑤使用局部变量；
  ⑥使用阻塞队列。

三、线程sleep()和wait()的区别
  来自不同的类，sleep是来自Thread，wait是来自Object
  sleep()方法没有释放锁，仅仅释放了CPU资源或者让当前线程停止执行一段时间，自动唤醒，需要try-catch，线程方法。
  wait()释放同步锁，需要notify唤醒。
  wait(),notify(),notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep()可以在任何地方使用。

四、线程的生命周期？（见图：Android/Image/线程的生命周期.png）
   ① 新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，
    但此时系统没有为其分配资源，这时的线程处于创建状态。
    线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。
   ② 就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，
    如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。
   ③ 运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。
   a) 可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，
    可能线程处于阻塞状态，也可能处于停止状态。
   ④ 阻塞和唤醒线程
   阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：
                 a)当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。
                 b)当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。
                 c)当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法
                  wait()/notify()方法的执行要求线程首先获得该对象的锁。
   ⑤ 死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。

五、终止线程的三种方法
  ① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。
  ② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。
  ③ 使用interrupt方法中断线程。

六、为什么要使用多线程？
   ①更好地利用CPU资源；
   ②进程间数据不能数据共享，线程可以；
   ③系统创建进程需要为该进程重新分配系统资源，创建线程代价较小；
   ④Java语言内置了多线程功能支持，简化了java多线程编程。

七、线程池
   1、【概念】一种多线程处理形式，处理过程中将任务添加到队列，在创建线程后自动启动这些任务，线程池线程是后台线程，每个线程都使用默认的堆栈大小，以优先级执行。
   线程的并行和并发

   并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
   并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。

   线程安全：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。
   线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。

   原理：
   1.在创建了线程池后，等待提交过来的任务请求。
   2.在调用execute（）方法添加一个请求任务时，线程池会做如下判断：
    2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
    2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；
    2.3 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务：
    2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会启动饱和拒绝策略来执行。
   3.当一个线程完成任务时，它会从队列中去下一个任务来执行。
   4.当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：
   如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小。

   2、Java通过Executors提供四种线程池（from 百度）
     Runtime.getRuntime().availableProcessors() == 6 ??
     newCachedThreadPool——创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程(至始至终一个线程执行)。
         ExecutorService executor = Executors.newCachedThreadPool();
         executor.shutdown();
     newFixedThreadPool——创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
         ExecutorService executor = Executors.newFixedThreadPool(1);
         executor.shutdown();
     newScheduledThreadPool——创建一个定长线程池，支持定时及周期性任务执行。
         ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
     newSingleThreadExecutor——创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(至始至终一个线程执行)。
         ExecutorService executor = Executors.newSingleThreadExecutor();

   3、流程
     ①线程池中的线程初始化
      创建线程池后，线程池中没有线程，需要提交任务才会创建线程。
      prestartCoreThread()：初始化一个核心线程；
      prestartAllCoreThreads()：初始化所有核心线程
     ②workQueue，任务缓存队列，用来存放等待执行的任务
     workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：
     　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；
     　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
     　　3）SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。
     ③任务拒绝策略
     当线程池的任务缓存队列已满或线程数目达到maximumPoolSize，还有任务来时会采用任务拒绝策略
        1）ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
        2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
        3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
        4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
     ④线程池的关闭
        1）shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
        2）shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务
     ⑤线程池容量的动态调整
       1）setCorePoolSize：设置核心池大小
       2）setMaximumPoolSize：设置线程池最大能创建的线程数目大小

   4、线程池的好处
      线程使应用能够更加充分合理的协调利用cpu 、内存、网络、i/o等系统资源。
      线程的创建需要开辟虚拟机栈，本地方法栈、程序计数器等线程私有的内存空间。
      在线程的销毁时需要回收这些系统资源。频繁的创建和销毁线程会浪费大量的系统资源，增加并发编程的风险。
      另外，在服务器负载过大的时候，如何让新的线程等待或者友好的拒绝服务？这些丢失线程自身无法解决的。

      所以需要通过线程池协调多个线程，并实现类似主次线程隔离、定时执行、周期执行等任务。线程池的作用包括：
      利用线程池管理并复用线程、控制最大并发数等。
      实现任务线程队列缓存策略和拒绝机制。
      实现某些与时间相关的功能，如定时执行、周期执行等。
      隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池，将较慢的交易服务与搜索服务隔开，避免个服务线程互相影响

   5、线程池的状态
      RUNNING	运行状态，该状态下线程池可以接受新的任务，也可以处理阻塞队列中的任务。执行 shutdown 方法可进入 SHUTDOWN 状态执行 shutdownNow 方法可进入 STOP 状态
      SHUTDOWN	待关闭状态，不再接受新的任务，继续处理阻塞队列中的任务。当阻塞队列中的任务为空，并且工作线程数为0时，进入 TIDYING 状态
      STOP	停止状态，不接收新任务，也不处理阻塞队列中的任务，并且会尝试结束执行中的任务，当工作线程数为0时，进入 TIDYING 状态
      TIDYING	整理状态，此时任务都已经执行完毕，并且也没有工作线程，执行 terminated 方法后进入 TERMINATED 状态
      TERMINATED	终止状态，此时线程池完全终止了，并完成了所有资源的释放

八、如何控制某个方法允许并发访问线程的个数？
  semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）
  semaphore.release() 释放一个信号量，此时信号量个数+1。

九、什么导致线程阻塞？线程如何关闭？
  阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。
  这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
  如何关闭：一种是调用它里面的stop()方法；另一种就是你自己设置一个停止线程的标记 （推荐这种）；
  使用中断interrupt(),但是它只是传递中断请求消息，并不代表立马停止目标线程。

十、线程的状态？
  New:新建状态，new出来，还没有调用start
  Runnable:可运行状态，调用start进入可运行状态，可能运行也可能没有运行，取决于操作系统的调度
  Blocked:阻塞状态，被锁阻塞，暂时不活动，阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。
  Waiting：等待状态，不活动，不运行任何代码，等待线程调度器调度，wait sleep
  Timed Waiting:超时等待，在指定时间自行返回
  Terminated:终止状态，包括正常终止和异常终止

十一、synchronized和volatile比较

    synchronized        [ˈsɪŋkrənaɪzd]   兴可奈子特
    volatile  不稳定的   [ˈvɒlətaɪl]      窝了太

   声明为volatile的变量，值是不确定的，需要从主存中读取；
     从主内存获取数据，将在所有线程中同步内存数据，在任意一个线程中修改，其他线程都会同步更新该变量的值；会消耗性能；
     只能声明变量无法声明方法。仅能实现变量的修改可见性，不能保证原子性；不阻塞线程；被标记的变量不会被编译器优化；
     volatile为实例域的同步访问提供了免锁机制，如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新

   声明为synchronized的
     性能没有volatile好，因为它有一个监听器，更改后就会通知锁定的线程，能保证操作的原子性；
     锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；当前线程更新后会同步其他所有线程，主要是因为同步主内存的数据；
     可以使用在类，方法，变量上；可以保证变量的修改可见性和原子性；会阻塞线程；标记的变量可以被编译器优化

   synchronized可修饰变量、方法和类，而volatile只能修饰变量
   synchronized可能会造成线程阻塞，而volatile不会造成线程的阻塞

   volatile不能保证线程安全而synchronized可以保证线程安全。
   volatile只能保证被其修饰变量的内存可见性，但如果对该变量执行的是非原子操作线程依旧是不安全的。
   而synchronized既可以保证其修饰范围内存可见性和操作的原子性，所以synchronized是线程安全的。

   要使 volatile 变量提供理想的线程安全性，必须同时满足两个条件：①对变量的写操作不依赖于当前值。②该变量没有包含在具有其他变量的不变式中。

十二、同步和异步
   同步和异步体现的是消息的通知机制：所谓同步，方法A调用方法B后必须等到方法B返回结果才能继续后面的操作；所谓异步，方法A调用方法B后可让方法B在调用结束后通过回调等方式通知方法A
   阻塞和非阻塞侧重于等待消息时的状态：所谓阻塞，就是在结果返回之前让当前线程挂起；所谓非阻塞，就是在等待时可做其他事情，通过轮询去询问是否已返回结果

