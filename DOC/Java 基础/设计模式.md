# 设计模式
一、单例：单例对象能保证在一个JVM中，该对象只有一个实例存在
    线程安全的单例
    public class SingleInstance{
            private static SingleInstance instance;

            public static SingleInstance getInstance(SingleInstance instance){
                if (instance == null) {
                    synchronized (SingleInstance.class) {
                        if (instance == null) {
                            instance = new SingleInstance();
                        }
                    }
                }
                return instance;
            }
    }

二、工厂模式
  一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。
  抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。
  每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。

三、适配器模式
  将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。
  主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。

四、装饰模式（Decorator）
  顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
  Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。

  装饰器模式的应用场景：
  1、需要扩展一个类的功能。
  2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）

  缺点：产生过多相似的对象，不易排错！

五、代理模式（Proxy）：多一个代理类出来，替原对象进行一些操作。

六、桥接模式（Bridge）：桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化。

七、观察者模式：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。

八、访问者模式：一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。