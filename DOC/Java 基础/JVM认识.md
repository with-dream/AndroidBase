# # JVM认识

【百度百科】
Java Virtual Machine：JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。
内存管理：
    （1）对于Java运行时涉及到的存储区域主要包括程序计数器、Java虚拟机栈、本地方法栈、java堆、方法区以及直接内存等等。
    对于每个部分，都有其使用的条件。程序计数器主要是取下一条指令，在Java里面主要是取下一条指令的字节码文件；
    Java虚拟机栈主要是利用栈先进后出的特性存储局部变量表，动态链接等，主要包括堆内存和栈内存，对于程序员内存分析而言是特别重要的。
    本地方法栈与上边的栈基本作用差不多，只不过这里是为Java方法而服务。Java堆是内存管理中最大的一块，所有的线程共享这一块内容，
    同时该部分也是垃圾收集器的主要区域。
    （2）虚拟机的垃圾回收机制是完善的，动态内存分配和回收是比较成熟的，在内存管理机制中，大部分都不需要我们考虑内存回收，
    只有Java堆和方法区需要我们考虑处理内存问题。一般的对于内存回收首先就是判断某一个部分是生存还是死亡，主要是通过下面二种算法：
       其一是引用计数算法，本算法实现简单，判定的效率也是比较高的，很多的软件都使用了该算法，但是主流的Java并没有选择该算法，
           核心的问题是该算法难以处理对象之间相互调用的问题。
       其二是称可达性分析算法，该算法核心思想是依靠判断对象是否存活来实现的，本算法是通过一系列的GC ROOTS的对象作为起始点，采用搜索的算法
           遍历引用链，如果搜索过程中没有发现该节点，则认为该节点是不可达的，即可回收的，在Java里面，一般可以使用该算法处理问题。


【https://www.jianshu.com/p/895deef15808】
JVM的内存空间：堆内存（新生代[Eden区、From Survivor区和To Survivor区]和老年代）、方法区、栈内存（java虚拟机栈和本地方法栈）
其中一部分是线程共享的，包括 Java 堆和方法区；另一部分是线程私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。

堆内存：是Java 虚拟机所管理的内存中最大的一块。堆是被所有线程共享的区域，实在虚拟机启动时创建的。
    堆里面存放的都是对象的实例（new 出来的对象都存在堆中），几乎所有的对象实例都在这里分配内存。

方法区：也称“永久代”（JVM不再有），用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。永久代是一片连续的堆空间，
    在JVM启动之前通过在命令行设置参数-XX:MaxPermSize来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM默认是85M）。

虚拟机栈(JVM Stack)：线程私有，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。
    虚拟机执行java程序时，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。
    栈帧又分为一下几个区域：局部变量表、操作数栈、动态连接、方法出口等。

本地方法栈（Native Method Stacks）：与虚拟机栈作用相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，
    而本地方法栈则是为虚拟机使用到的Native方法服务。

程序计数器：记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。
    Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

  直接内存：
     直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，
     它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。


1、Young Generation
由一个Eden区和两个Survivor区组成，程序中生成的大部分新的对象都在Eden区中，当Eden区满时，
还存活的对象将被复制到其中一个Survivor区，当次Survivor区满时，此区存活的对象又被复制到另一
个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代。

2、Old Generation
一般情况下，年老代中的对象生命周期都比较长。

3、Permanent Generation
用于存放静态的类和方法，持久代对垃圾回收没有显著影响。
总结：内存对象的处理过程如下：
1、对象创建后在Eden区。
2、执行GC后，如果对象仍然存活，则复制到S0区。
3、当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。
4、当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation。 5、当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old
Generation，最后累积一定时间再移动到Permanent Generation区域。
系统在Young Generation、Old Generation上采用不同的回收机制。每一个Generation的内存区域都
有固定的大小。随着新的对象陆续被分配到此区域，当对象总的大小临近这一级别内存区域的阈值时，
会触发GC操作，以便腾出空间来存放其他新的对象。
执行GC占用的时间与Generation和Generation中的对象数量有关：
Young Generation < Old Generation < Permanent Generation
Gener中的对象数量与执行时间成正比。

4、Young Generation GC
由于其对象存活时间短，因此基于Copying算法（扫描出存活的对象，并复制到一块新的完全未使用的
控件中）来回收。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young
Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。

5、Old Generation GC
由于其对象存活时间较长，比较稳定，因此采用Mark（标记）算法（扫描出存活的对象，然后再回收未
被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效
率损耗）来回收。

在Android系统中，GC有三种类型：
1、GcCauseForAlloc：分配内存不够引起的GC，会Stop World。由于是并发GC，其它线程都会停止，直到GC完成。
2、GcCauseBackground：内存达到一定阈值触发的GC，由于是一个后台GC，所以不会引起Stop World。
3、GcCauseExplicit：显示调用时进行的GC，当ART打开这个选项时，使用System.gc时会进行GC。
